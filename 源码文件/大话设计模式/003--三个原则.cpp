/*
* 单一职责原则：：就一个类而言，应该仅有一个引起它变化的原因
*                 如果一个类承担的职责过多，等于把这些职责耦合在一起，一个职责变化可能会削弱或者抑制这个类的其他职责能力
*                 如果能想到多余一个动机去改变一个类，那么这个类就具有多余一个职责
* 开放-封闭原则：：软件实体（类，模块，函数等）应该可以扩展，但是不可以修改
*                  对扩展是开放的，对修改是封闭的，在最初编写代码时，假设变化不会发生。当变化发生时，就创建抽象来隔离以后发生的同类变化
*                  面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码
* 依赖倒转原则：：A:高层模块不应该依赖低层模块。两个都应该依赖抽象
*                 B:抽象不应该依赖细节。细节应该依赖抽象
*				  针对抽象编程，而不是针对实现编程
* 里氏代换原则：：子类型必须能够替换掉它们的父类型
*                 一个软件实体如果使用的是一个父类的话，那么一定适用其子类，而且它察觉不出父类对象和子类对象的区别，把父类全替换成子类，程序没有变化
*                 子类的可替换性使得父类在无需修改的情况下可以扩展
*/
#include <iostream>
#include <string>
using namespace std;

int main()
{
	cout << "hello world" << endl;

	system("pause");
	return 0;
}
