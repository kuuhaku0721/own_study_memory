**1、**list容器的迭代器iterator与vector和deque不同，list容器的迭代器不支持<运算，仅支持递增，递减，==以及！=运算，因为vector和deque在内存中连续保存，而list则是将元素以链表方式存储，两个指针的大小关系与元素的前后关系并不一定吻合

**2、**begin和cbegin的区别：cbegin是C++新标准引入的，用来与auto结合适用，它返回指向容器第一个元素的const迭代器，可以用来只读地访问容器元素，但不能对容器元素进行修改。因此，当不需要写访问时，应该适用cbegin。

3、begin和auto配合适用时，会根据调用对象地类型来决定迭代器地类型，如 

```c++
vector<int> v1;
const vector<int> v2;
auto it1 = v1.begin(), it2 = v2.begin();
auto it3 = v1.cbegin(), it4 = v2.cbegin();
```

上述代码中：it1是普通迭代器，it2是const迭代器，cbegin无论调用对象是什么类型，始终返回const迭代器，因此it3和it4都是const迭代器

4、创建拷贝时，接受一个容器创建其拷贝，我们将得到此容器地一个一模一样地拷贝，当我们只想拷贝其中的一部分元素时，可以接受两个迭代器来对范围内元素进行拷贝。范围拷贝也可以有如下用法

```c++
list<int> ilist;
vector<double> ivec(ilist.begin(), ilist.end()); //用list容器去初始化vector容器
```

5、标准库容器支持关系运算符，如果想要比较两个vector是否相等，可以直接适用==运算符

6、auto的用法：根据后面的值，来自己推测前面的类型是什么，作用是为了简化变量初始化。

```c++
vector<string> v;
vector<string>::iterator it = v.begin();
auto it = v.begin();  //简化后

//如果对象是迭代器的话还可以
for(auto i : v)
{
    cout << i << " "; //遍历vector容器内每个元素
}
```

7、容器如vector的insert算法有返回值，返回的是插入的数据的当前迭代器，同时需要注意的时，如果是在循环的过程中插入了数据，那么当前循环就会失效(多了一个元素)。erase删除元素也是如此，如果删除了一个元素，会导致此元素之后的迭代器、引用和指针失效(list的删除操作不会使迭代器失效)。解决办法也是将erase返回的迭代器重复值给it(循环条件)

8、forward_list：与list不同的是 forward_list 是单向链表数据结构，只有前驱节点指向后继节点的指针，而没有反向的指针。因为 forward_list 可以高效地从前驱转到后继，但无法从后继转到前驱。因此，在 forward_list 中插入、删除元素既需要该元素地迭代器，也需要前驱迭代器。为此，forward_list提供了before_begin来获取首元素之前位置的迭代器，且插入、删除都是_after形式，即删除给定迭代器的后继。代码样例如下：

```c++
forward_list<int> iflst = {1,2,3,4,5,6,7,8};
auto prev = iflst.before_begin(); //前驱元素
auto curr = iflst.begin(); //当前元素
curr = iflst.erase_after(prev); //删除，移动到下一元素
//遍历还是 begin() --> end()
```

9、关于resize，对于接受单个参数的resize版本对元素类型的限制：对于元素类型是类 类型，则单参数resize版本要求该类型必须提供一个默认构造参数

10、我们知道，capacity返回的是为容器(如vector)分配的空间，也就是在不分配新空间情况下，容器可以保存多少个元素，而size返回当前已经保存的元素的个数。但是list和array没有capacity成员函数，因为list是用链表进行存储的，当插入新的元素时，会从内存中分配一个新节点保存它，因此没有capacity成员函数。而array是固定大小数组，内存一次性分配，大小不变，不会变化，因此不需要capabilities函数。

11、<string>容器的函数

```c++
string::size_type pos = 0;
while ((pos = s.find_first_of(chars, pos)) != string::npos) //找到字符
{
	cout << "pos:" << pos << "，char：" << s[pos] << endl;
	pos++; //移动到下一字符
}
```

​			size_type:抽象意义是尺寸单位类型,不同机器字长可能不一样，size_type可以匹配当前极其字长  pos：拿到当前位置字符， find_first_of 查找第一个在给定字符集出现的字符  npos:当找不到匹配的类型时，返回的是npos的值

12、find是将子串当作一个字符串整体在主串中查找，而find_first_of 和 find_first_not_of是将子串当作一个字符集合在主串中查找其中字符

13、标准库提供了将字符串转换为整型函数stoi，不同的如长整型，无符号整型等类型也都有相应的版本

```c++
vector<string> vs = {"123", "+456", "-789"};
int sum = 0;  //vs中字符串的整型的和
for(auto it = vs.begin(); it != vs.end(); it++)
{
	sum += stoi(*it);
}
//和就是sum的最终结果
```

14、inline和size_t 

inline：为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 **inline** 修饰符，表示为内联函数。栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。inline 只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数.

​		慎用inline，如果代码体本身比较复杂，会造成内存消耗代价较高等不良后果。

size_t：实际上C/C++中的sizeof 是一个运算符，sizeof 运算符的结果是 size_t ，它是由 typedef 机制定义出来的”新”类型。

```c++
//size_t是全局定义的类型；size_type是STL类中定义的类型属性，用以保存任意string和vector类对象的长度

//string::size_type 制类型一般就是unsigned int, 但是不同机器环境长度可能不同 win32 和win64上长度差别；size_type一般也是unsigned int

```

15、关于throw的一个简单用法，可以在if或者其他条件判断语句之后进行异常抛出操作，类似于java的throw操作

```c++
throw invalid_argument("未匹配右括号");
//或
if (so.size() != 1 || so.top().t != VAL)
{
	throw invalid_argument("非法表达式");
}
```

16、equal使用==运算符比较两个序列中的元素。string类重载了==，可比较两个字符是否长度相等且元素对应位置相等。而C风格字符串本质是char*  类型，用==比较两个 char*  类型。只是检查两个指针值是否相等，即地址是否相等，而不是比较其中字符是否相同。所以，只有当两个序列中的指针都指向相同地址时，equal才会返回true。

17、注意使用泛型算法fill_n时，对于容器内的要求时具有足够的元素而不是足够的空间。即使已经利用reserve为vector分配了10个int的内存空间，但是因为没有元素，所以对于fill_n来说，vector内仍然为空，fill_n会失败,修改方法时，传递给算法插入器back_inserter,这类迭代器能调用下层容器的操作来向容器内插入元素。

```c++
vector<int> vec;
vec.reserve(10);
fill_n(vec.begin(),10,0); //这样子是不行的
//修改方法如下
fill_n(back_inserter(vec), 10, 0); //利用插入器就能向里面正确插入元素
```

18、算法不改变容器大小的原因：泛型算法的一大优点是“泛型”，也就是一个算法可用于多种不同的数据类型，算法于所操作的数据结构分离。这对编程效率的提高是非常巨大的。

​		要做到算法与数据结构分离，重要的技术手段就是使用迭代器作为两者的桥梁。算法从不操作具体的容器，从而也就不存在与特定容器绑定，不适用于其他容器的问题。算法只操作迭代器，由迭代器真正实现对容器的访问。不同容器实现自己特定的迭代器（但不同迭代器是相容的），算法操操作不同迭代器就实现了对不同容器的访问。

​		因此，并不是算法应该改变或不改变容器的问题。为了实现与数据结构的分离，为了实现通用性，算法根本就不该知道容器的存在。算法访问数据的唯一通道是迭代器。是否改变容器大小，完全是迭代器的选择和责任。

19、lambda无需使用所在函数中定义的局部变量，所以捕获列表为空。参数列表为两个整型。返回类型由函数体唯一的语句----返回语句推断即可。以下是一个简单的lambda，接受两个int求和

```c++
int main()
{
	auto sum = [] (int a, int b) {return a + b;}; //分号不要丢
	cout << sum(1,1) << endl; //1+1=2
	
	system("pause");
	return 0;
}
```

20、三种插入迭代器的不同之处：之前已经提到过back_inserter。除了back_inserter以外，标准库还提供了另外两种插入器：front_inserter和inserter。三者的差异在于如何向容器插入元素；back_inserter调用push_back, front_inserter调用 push_front，inserter则调用insert。显然，这也决定了它们插入元素位置的不同。back_inserter总是插入容器尾元素之后，front_inserter总是插入容器首元素之前，而inserter则是插入到给定位置（作为inserter的第二个参数传递给它）之前。因此，需要注意这些特点带来的元素插入效果的差异。例如，使用front_inserter向容器插入一些元素，元素最终在容器中的顺序与插入顺序相反，但back_inserter和inserter则不会有这个问题。

21、关于流迭代器的使用：部分代码如下，详细的在另外的文档

```c++
#include <iostream>
#include <string>
#include<fstream>
#include<vector>
#include<algorithm>
#include<iterator>
using namespace std;

int main()
{
	//创建流迭代器从标准输入读入整数
	istream_iterator<int> in_iter(cin);
	//尾后迭代器
	istream_iterator<int> eof;
	
	vector<int> v;
	while (in_iter != eof)
	{
		v.push_back(*in_iter++); //存入vector并递增迭代器
	}

	sort(v.begin(), v.end());

	ostream_iterator<int> out_iter(cout, " ");
	unique_copy(v.begin(), v.end(), out_iter);


	system("pause");
	return 0;
}

//使用流迭代器的输出
ostream_iterator<int> out_iter(cout, " ");
vector<int> v = { 0,1,2,3,4,5,6,7,8,9 };
//用流迭代器和copy输出int序列
copy(v.begin(), v.end(), out_iter);
cout << endl;
```

22、反向迭代器如rbegin,rend等，借助反向迭代器可以扩展算法的能力。例如，使用普通迭代器，find能查找给定值在容器中第一次出现的位置。如果要查找最后一次出现的位置，还使用普通迭代器的化，代码会很复杂。但借助反向迭代器，find可以逆序遍历容器中的元素，从而“第一次出现位置”实际上就是正常顺序的最后一次出现的位置了。

```c++
list<int> li = { 0,1,2,0,3,4,5,0,6 };
//利用反向迭代器查找最后一个0
auto last_zero = find(li.rbegin(), li.rend(), 0);
```

23、五种迭代器以及每类迭代器所支持的操作：

​		1、输入迭代器：只读，不写；单遍扫描，只能递增；还支持相等性判定运算符(==,!=)、解引用运算符(*)(只出现在赋值运算符右侧)和箭头运算符(->)

​		2、输出迭代器：只写，不读；单遍扫描，只能递增，支持解引用运算符(*)(只出现在赋值运算符左侧)

​		3、前向迭代器：可读写；多遍扫描，只能递增，支持所有输入、输出迭代器的操作。

​		4、双向迭代器：可读写，多遍扫描，可递增递减，支持所有前向迭代器的操作。

​		5、随机访问迭代器：可读写，多遍扫描，支持全部迭代器运算，除了上述迭代器类别支持的操作外，还有比较两个迭代器相对位置的关系运算符(<,<=,>和>=)、迭代器和一个整数值的加减运算(+,+=,-和-=)令迭代器在序列中前进或后退给定整数个元素，两个迭代器上的减法运算符(-)得到其距离以及下标运算符。

24、list上的迭代器是双向迭代器，vector上的迭代器是随机访问迭代器。

25、copy要求前两个参数至少是输入迭代器，表示一个输入范围。它读取这个范围中的元素，写入到第三个参数代表的输出序列中，因此第三个参数至少是输出迭代器。

​		reverse要反向处理序列，因此它要求两个参数至少是双向迭代器。

​		unique顺序扫描元素，覆盖重复元素，因此要求两个参数至少是前向迭代器。“至少”意味着能力更强的迭代器是可接受的。

26、关于map（关联容器）和vector（顺序容器）的不同：两类容器的根本区别在于，顺序容器中的元素是“顺序”存储的（链表在逻辑上是顺序存储的）。理解顺序的关键是理解容器支持的操作形式以及效率。

​		对于vector这样的顺序容器，元素在其中按顺序存储，每个元素有唯一对应的位置编号，所有操作都是按编号（位置）进行的。例如，获取元素（头，尾，用下标获取任意位置）。插入删除元素（头，尾，任意位置）、遍历元素（按元素位置顺序一一访问）。底层的数据结构是数组，链表，简单但已经能保证上述操作的高效。而对于依赖值的元素访问，例如查找（搜索）给定值（find），在这种数据结构上的实现是要通过遍历完成的，效率不佳。

​		而map这种关联容器，就是为了高效实现“按值访问元素”这类操作而设计的。为了达到这一目的，容器中的元素是按关键字值存储的，关键字值与元素数据建立起对应关系，这就是“关联”的含义。底层数据结构是红黑树，哈希表等，可高效实现按关键字值查找，添加，删除元素等操作。

27、关于map和set的差别：当需要查找给定值所对应的数据时，应使用map，其中保存的是<关键字，值>对，按关键字访问值。 如果只需判定给定值是否存在时，应使用set，它是简单的值的集合。

28、关于set和list的区别：两者都可以保存元素集合。如果只需要顺序访问这些元素，或是按位置访问元素，那么应使用list。如果需要快速判定是否有元素等于给定值，则应使用set。

29、在保存不重复元素的时候，选择使用vector和set的区别：使用vector保存不重复单词，需要用find查找新读入的单词是否已在vector中，若不在（返回尾后迭代器）才将单词加入vector。而使用set，检查是否重复的工作是由set模板负责的，程序员无需编写对应代码，程序简洁很多。

​		更深层次的差别，vector是无序线性表，find查找指定值只能采用顺序查找方式，所花费的时间与vector.size()呈线性关系。而set是用红黑树实现的，花费的时间与vector.size()呈对数关系。当单词数量非常多时，set的性能优势是巨大的。（另，vector保存时可以保持单词的输入顺序，而set默认按升序排列

30、vector::iterator 支持比较操作，而list::vector不支持比较操作

31、set的迭代器是const的，因此只允许访问set中的元素，而不能改变set。与map一样，set的关键字也是const，因此也不能通过迭代器来改变set中元素的值。

32、find和count：find查找关键字在容器中出现的位置，而count则还会统计关键字出现的次数。因此，当我们希望知道（允许重复关键字的）容器中有多少元素的关键字与给定关键字相同时，使用count。当我们只关心关键字是否在容器中时，使用find就足够了。特别是，对于不匀速重复关键字的关联容器，find和count的效果没什么区别，使用find就可以了。或者，当我们需要获取具有给定关键字的元素（而不只是统计个数）时，也需要使用find。find和下标操作有一个重要区别，当给定关键字不在容器中时，下标操作会插入一个具有该关键字的元素。因此，当我们想检查给定关键字是否存在时，应该用find而不是下标操作。

33、multimap的数据结构是红黑树，它维护了元素的关键字的默认序。例如，对字符串关键字，红黑树会维护它们的字典序，当我们遍历multimap（如[begin(), end()] 或简单的使用sort）时，就是按关键字的字典序来访问元素。（注意关联容器的迭代器不是随机迭代器，不能通过sort使其内部元素呈现出另外一种顺序）。

34、一个容器的无序版本和有序版本相比：无序版本通常性能更好，使用也更为简单，有序版本的优势是维护了关键字的序。  当元素的关键字类型没有明显的序关系，或是维护元素的序代价非常高时，无序容器非常有用。 但当应用要求必须维护元素的序时，有序版本就是唯一的选择。

35、关于<memory> 和 shared_ptr 见另一个文件 .xmind

36、有一个标志性题目

```c++
/*下面的函数是否有错误？如果有，解释错误原因*/
bool b()
{
    int *p = new int;
    // .....
    return p;
}
/*
* 从程序片段看，可以猜测程序员的意图是通过new返回的指针值来区分内存分配成功或失败--成功返回一个合法指针，转换为整型是一个非零值，可转换为bool值true； 分配失败，p得到nullptr，其整型值是0，可转换为bool值false。
	但普通new调用在分配失败时抛出一个异常bad_alloc， 而不是返回 nullptr， 因此程序不能达到预想的目的。
	可将new int 改为 new (nothrow) int 来令new在分配失败时不抛出异常，而是返回nullptr。但这仍然不是一个好办法，应该通过捕获异常或是判断返回的指针来返回true或false，而不是依赖类型转换。
*/
```

37、通过下面代码理解直接管理内存和只能指针的差别

```c++
int* q = new int(42), *r = new int(100);
r= q;
auto q2 = make_shared<int>(42), r2 = make_shared<int>(100);
r2 = q2;
```

//ps:这一大段话特地抄下来只是为了看一遍有个印象，其实基本没看懂

​	这段代码非常好地展示了智能指针在管理内存上的优点。

​	对于普通指针部分，首先分配了两个int型对象，指针分别保存在p和r中。接下来，将指针q的值赋予了r，这带来了两个非常严重的内存管理问题：

​	1、首先是一个直接的内存泄露问题，r和q一样都指向42的内存地址，而r中原来保存的地址--100的内存再无指针管理，变成“孤儿内存”，从而造成内存泄漏。

​	2、其次是一个“空悬指针”问题。由于r和q指向同一个动态对象，如果程序编号不当，很容易产生释放了其中一个指针，而继续使用另一个指针的问题。继续使用的指针指向的是一块已经释放的内存，是一个空悬指针，继续读写它指向的内存可能导致程序崩溃甚至系统崩溃的严重问题。

​	而shared_ptr则可很好地解决这些问题。首先，分配了两个共享的对象，分别由共享指针p2和q2指向，因此它们的引用计数均为1。接下来，将q2赋予r2。赋值操作会将q2指向的对象地址赋予r2，并将r2原来指向的对象的引用计数减1，将q2指向的对象的引用计数加1.这样，前者的引用计数变为0，其占用的内存空间也会被释放，不会造成内存泄露。而后者的引用计数变为2，也不会因为r2和q2之一的销毁而释放它的内存空间，因此也不会造成空悬指针的问题。

38、关于char*字符串和string字符串：

​		对于字符串字面常量（即字符数组），可以使用strcpy将第一个字符串拷贝到动态数组中，然后用strcat将第二个字符串连接到动态数组中。

​		对于两个string对象，使用+运算符即可简单实现连接。然后用c_str获取连接结果（临时string对象）的内存地址，用strcpy拷贝到动态数组即可。

​		最后不要忘记释放动态数组。（记忆点：strcpy，c_str，strcat）

但是！！strcpy和strcat 在vs不能用，会提示不安全（可以通过代码消除但不推荐），改用strcpy_s和strcat_s

```c++
strcpy_s(D,sizeof（S）+1,S); //把S复制给D 把S的大小也给D 返回D.
strcat_s(A,sizeof(A)+sizeof(B)+1,B); //很好理解 空间一定是两个数组之和 再加一。
```

39、动态数组处理变长输入：根据动态分配的字符数组的大小确定字符串长度阈值，当读取的字符数超出阈值时，停止读取，即采取了截断的方式。还可采取其他处理方式，如抛出异常等。另外，为了能读取空格等空白符，程序中可以使用get操作来读取字符.

40、使用allocator去分配内存，定义allocator<string> alloc; 使用alloc.allocate来分配裸内存，而不会初始化string，用alloc.construct来初始化string，最后用alloc.deallocate来释放内存，注意定义时要确定分配内存的数组，释放时也要释放同样数目的内存。STL容器需要有分配器的参数但是默认都有，不用特地自己写，最好不要写。

41、拷贝构造函数的基本概念：如果拷贝构造函数的第一个参数是自身类类型的引用，且所有其他参数（如果有的话）都有默认值，则此构造函数是拷贝构造函数。拷贝构造函数在以下几种情况下会被使用：

​		拷贝初始化（用=定义变量）

​		将一个对象作为实参传递给非引用类型的形参。

​		一个返回类型为非引用类型的函数返回一个对象。

​		用花括号列表初始化一个数组中的元素或一个聚合类中的成员。

​		初始化标准库容器或调用其insert/push操作时，容器会对其元素进行拷贝初始化。

42、右值引用和左值引用的区别：

​		所谓右值引用就是必须绑定到右值的引用，通过&&获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。

​		左值引用，也就是“常规引用”，不能绑定到要转换的表达式、字面常量或返回右值的表达式。而右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。

​		返回左值的表达式包括返回左值引用的函数及赋值、下标、解引用和前置递增/递减运算符，返回右值的包括返回非引用类型的函数及算数、关系、位和后置递增/递减运算符。可以看到，左值的特点是有持久的状态，而右值则是短暂的。

43、深入理解左值引用和右值引用

```c++
//什么类型的引用可以绑定到下面的初始化器上
int f();
vector<int> vi(100);
int? r1 = f();
int? r2 = vi[0];
int? r3 = r1;
int? r4 = vi[0] * f();
```

​	r1必须是右值引用，因为f是返回非引用类型的函数，返回的是一个右值

​	r2必须是左值引用，因为下标运算符返回的是左值。

​	r3只能是左值引用，因为r1是一个变量，而变量是左值。

​	r4只能是右值引用，因为vi[0] * f() 是一个算数运算表达式，返回右值。、

44、重载运算符和内置运算符的区别：

​	不同点：重载操作符必须具有至少一个class或枚举类型的操作数。 重载操作符不保证操作数的求值顺序，例如对&&和||的重载版本不再具有“短路求值”的特性，两个操作数都要进行求值，而且不规定操作数的求值顺序。

​	相同点：对于优先级和结合性及操作数的数目都不变。

45：关于重载是否应该是类成员

​	%  通常定义为非成员

​	%=  通常定义为类成员，因为它会改变对象的状态。

​	++  通常定义为类成员，因为它会改变对象的状态。

​	->  必须定义为类成员，否则编译会报错。

​	<<  通常定义为非成员。

​	&&  通常定义为非成员。

​	==  通常定义为非成员。

​	()  必须定义为类成员，否则编译会报错。

46、通过调用operator+=来定义operator+比其他方法更有效，因为从头实现operator+的方式与借助operator+=实现的方式相比，在性能上没有优势，而在可读性上后者显然更好。

46、在C++11中，lambda是通过匿名的函数对象来实现的，因此我们可以把lambda看作是对函数对象在使用方式上进行的简化。  当代码需要一个简单的函数，并且这个函数并不会在其他地方被使用时，就可以使用lambda来实现，此时它所起的作用类似于匿名函数。  但如果这个函数需要多次使用，并且它需要保存某些状态的话，使用函数对象则更合适一些。

47、虚函数，虚成员：在类中被声明为virtual的成员，基类希望这种成员在派生类中重定义。除了构造函数外，任意非static成员都可以为虚成员。

48、protected和private的访问权限不同之处：protected为受保护的访问标号，protected成员可以被该类的成员，友元和派生类成员（非友元）访问，而不可以被该类型的普通用户访问。而private成员只能被基类的成员和友元访问，派生类不能访问。

49、区分静态类型和动态类型：静态类型在编译时就已经确定了，它是变量声明时的类型或表达式生成的类型；而动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才能知道。如Quote* pQuote = new  Bulk_quote; 指针pQuote的静态类型是Quote，在编译时就已经确定了。但是它的动态类型是Bulk_quote，知道运行时才能知道它指向的是基类还是派生类。如果一个变量非指针也非引用，则它的静态类型和动态类型永远一致。但基类的指针或引用的动态类型可能与其动态类型不一致。

50、有必要将一个成员函数同时声明成override和final吗？为什么？

​		override：在C++11新标准中我们可以使用override关键字来说明派生类中的虚函数。这么做的好处是在使得我们的意图更加清晰即明确地告诉编译器我们想要覆盖掉已存在的虚函数。如果定义了一个函数与基类中的名字相同但是形参列表不同，在不适用override关键字的时候这种函数定义是合法的，在使用了override关键字之后这种行为是非法的，编译器会提示出错。

​		final：如果我们将某个函数定义成final，则不允许后续的派生类来覆盖这个函数，否则会报错。

​		因此同时将一个成员函数声明成override和final能够使我们的意图更加清晰。

51、哪些类需要虚析构函数？虚析构函数必须执行什么样的操作？

​		作为基类使用的类应该具有虚析构函数，以保证在删除指向动态分配对象的基类指针时，根据指针实际指向的对象所属的类型运行适当的析构函数。

​		虚析构函数可以为空，即不执行任何操作。一般而言，析构函数的主要作用是清楚本类中定义的数据成员。如果该类没有定义指针类成员，则使用合成版本即可（默认给出的）；如果该类定义了指针成员，则一般需要自定义析构函数以对指针成员进行适当的清除。因此，如果有虚析构函数必须执行的操作，那就是清楚本类中定义的数据成员的操作。

52、注意一个问题：如果定义了析构函数（比如析构函数内打印内容了），并且在main函数内写了system("pause")那么在按任意键之后会打印析构函数内的内容，然后程序结束，不按任意键的话析构函数并不会执行。

53、实例化的定义：当调用一个函数模板时，编译器会利用给定的函数实参来推断模板实参，用此实际实参代替模板参数来创建出模板的一个新的“实例”，也就是一个真正可以调用的函数，这个过程称为实例化。

54、几个模仿标准库写的模板，用处比较大的，需要记一记

```c++
//返回数组的大小
template <typename T, size_t N>
constexpr int arr_size(const T(&a)[N])
{
	return N;
}
//打印任意类型的数组
template<typename T, size_t N>
void print(const T(&a)[N])
{
	for (auto iter = begin(a); iter != end(a); iter++)
	{
		cout << *iter << " ";
	}
	cout << endl;
}
//begin和end迭代器
template <typename T, size_t N>
const T* my_begin(const T(&a)[N])
{
	return &a[0];
}

template <typename T, size_t N>
const T* my_end(const T(&a)[N])
{
	return &a[0] + N;
}
```

55、C++程序员喜欢使用！=而不喜欢< 理由是？

​		泛型编程的一个重点：算法对类型要求决定了算法的适用范围。

​		泛型编程的一个目标就是令算法是“通用的”----适用于不同类型。所有标准库容器都定义了==和!=运算符，但其中只有少数定义了< 运算符。因此，尽量使用!= 而不是< ，可减少你的算法适用容器的限制。

56、什么是函数模板？什么是类模板？

​		函数模板是可以实例化出特定函数的模板，类模板是可以实例化出特定类的模板。从形式上来说，函数模板与普通函数类似，只是要以关键字template开始，后接模板参数列表，类模板与普通类的关系类似。在使用上，编译器会根据调用来为我们推断函数模板的模板参数类型，而使用类模板实例化特定类就必须显式指定模板参数。

57、类模板的实例化过程：当我们使用一个类模板时，必须显式提供模板实参列表，编译器将它们绑定到模板参数，来替换类模板定义中模板参数出现的地方，这样，就实例化出一个特定的类。我们随后使用的其实就是这个特定的类。需要特别注意的是：类模板的名字不是一个类型名，只有实例化后才能形成类型（就是vector<int>这种）,而实例化总是要提供模板实参的。（不像普通类实例化Person zhangsan这样而是需要<>）。

58、声明为typename的类型参数和声明为class的类型参数有什么不同？什么时候必须使用typename？

​		当用来声明模板类型参数时，typename和class是完全等价的，都表明模板参数是一个类型。在C++最初引入模板时，是使用class的。但为了避免与类（或类模板）定义中的class相混淆，引入了typename关键字。从字面上看，typename还暗示了模板类型参数不必是一个类类型。因此，现在更建议使用typename。

​		此外，typename还有其他用途，当在模板类型参数上使用作用域运算符:: 来访问其成员时，如T::value_type， 在实例化之前可能无法辨别访问的到底是静态成员还是类型成员。对此，C++默认通过:: 访问的是静态成员。为了指明访问的是类型成员，需要在名字前使用typename 关键字，如typename T::value_type(), 表明value_type是类型成员，这里是创建一个value_type类型的对象，并进行值初始化。

59、在模板实参推断过程中发生了什么？ 对一个函数模板，当我们调用它时，编译器会利用调用中的函数实参来推断其模板参数，这些模板实参实例化出的版本与我们的函数调用应该是最匹配的版本，这个过程就成为模板实参推断。

60、在模板实参推断过程中，如果函数形参的类型使用了模板类型参数，则只允许进行两种类型转换。

​		1--const转换：可以将一个非const对象的引用（或指针）传递给一个const对象（或指针）形参。

​		2--数组或函数到指针的转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。

61、模板特化和重载的区别：

​		重载是会影响函数匹配的，也就是说，编译器在函数匹配过程中会将新的重载版本作为候选之一来选择最佳匹配。这就需要小心设计，避免实际匹配不如我们所愿。

​		特例化则不影响函数匹配，他并不是为编译器进行函数匹配提供一个新的选择，而是为模板的一个特殊实例提供不同于原模版的特殊定义，本质上是接管了编译器在完成函数匹配后的部分实例化工作。即，当某个模板是最佳匹配时，且需要实例化这个特殊实例时，不再从原模板进行实例化，而是直接使用这个特例化版本。因此，特例化更为简单——当某个模板不符合我们的需求时，只需设计满足需求的特例化版本即可。

62、try——catch语句的三个catch异常

​		exception、runtime_error及overflow_error是标准库中定义的异常类，它们是继承而相关的：runtime_error类继承exception类，overflow_error类继承runtime_error类，在使用来自继承层次的异常时，catch子句应该从最低派生类型到最高派生类型排序，以便派生类型的处理代码出现在其基类类型的catch之前。

63、为什么what函数不应该抛出异常？

​		what函数是在catch异常后用于提取异常基本信息的虚函数，what函数是确保不会抛出任何异常的。如果what函数抛出了异常，则会在新产生的异常中由于what函数继续产生异常，将会产生抛出异常的死循环。所以what函数必须确保不抛出异常。

64、通常，当需要声明局部于文件的实体时，可以使用未命名的命名空间，即在文件的最外层作用域中定义未命名的命名空间。

65、普通的数据指针与指向数据成员的指针的区别在于：指定指向数据成员的指针类型时，除了给出成员本身的类型之外，还必须给出所属类的类型。例如：指向int型数据的普通数据指针的类型为int*，而指向C类的int型数据成员的成员指针的类型为int C::※

```c++
//合适一个成员指针
Screen myScreen;
myScreen .*pm;
```

66、普通函数指针和指向成员函数的指针的区别在于：指定指向成员函数的指针类型时，除了给出成员本身的类型之外，还必须给出成员函数所属类的类型并指明成员函数是否为const。例如：指向int型数据的普通数据指针的类型为int*，指向“不带参数并返回int型值的函数”的普通函数指针的类型为int(※)()，而指向“C类的不带参数并返回int型值的const成员函数”的函数成员指针的类型为int(C::※)()const。

67、关于异常处理机制

​	异常是程序在执行期间产生的问题。C++异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。异常提供了一种转移程序控制权的方式。C++异常处理涉及三个关键字：try catch throw

```c++
#include <exception>
throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。
catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。
try:   try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。
```

如果有一个块抛出一个异常，捕获异常的方法是使用try来捕获异常，并通过catch块处理异常。如：

```c++
try
{
   // 保护代码
}catch( ExceptionName e1 )
{
   // catch 块
}catch( ExceptionName e2 )
{
   // catch 块
}catch( ExceptionName eN )
{
   // catch 块
}
```

或者也可以使用throw语句在代码块的任何地方抛出异常。throw语句的操作数可以是任意的表达式，表达式的结果类型决定了抛出的异常的类型。如：

```c++
double division(int a, int b)
{
   if( b == 0 )
   {
      throw "Division by zero condition!";
   }
   return (a/b);
}
```

同时，所有异常类均重载了what()函数，它将返回异常产生的原因。如：

```c++
try
  {
    throw MyException();
  }
  catch(MyException& e)
  {
    std::cout << "MyException caught" << std::endl;
    std::cout << e.what() << std::endl;
  }
  catch(std::exception& e)
  {
    //其他的错误
  }
```

68、lambda表达式是在调用或作为函数参数传递的位置处定义匿名函数对象的便捷方法。通常lambda用于封装传递给算法或异步方法的几行代码。如下面是一个简单的lambda表达式

```c++
void abssort(float* x, unsigned n) 
{
    std::sort(x, x + n,
        // Lambda expression begins
        [](float a, float b) {
            return (std::abs(a) < std::abs(b));
        } // end of lambda expression
    );
}
```

lambda的基本结构为： 捕获列表   参数列表  可变规则  返回类型  函数体

​	1--捕获列表。在C ++规范中也称为Lambda导入器， 捕获列表总是出现在Lambda函数的开始处。实际上，[]是Lambda引出符。编译器根据该引出符判断接下来的代码是否是Lambda函数，捕获列表能够捕捉上下文中的变量以供Lambda函数使用。
​	2--参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号“()”一起省略。
​	3--可变规格*。mutable修饰符， 默认情况下Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。*
​	4--异常说明。用于Lamdba表达式内部函数抛出异常。
​	5--返回类型。 追踪返回类型形式声明函数的返回类型。我们可以在不需要返回值的时候也可以连同符号”->”一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。如使用auto
​	6--lambda函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。

编译器会把一个lambda表达式生成一个匿名类的匿名对象，并在类中重载函数调用运算符,实现了一个operator()方法。因此使用Lamdba表达式语法比较灵活，但是增加了阅读代码的难度并且对于函数复用无能为力。

​	下面几个lambda的使用示例。

```c++
//[]表示不捕获任何变量
auto function = ([]{
		std::cout << "Hello World!" << std::endl;
	}
);
//[var]表示值传递方式捕获变量var
int num = 100;
auto function = ([num]{
		std::cout << num << std::endl;
	}
);
//[=]表示值传递方式捕获所有父作用域的变量（包括this）
int index = 1;
int num = 100;
auto function = ([=]{
			std::cout << "index: "<< index << ", " 
                << "num: "<< num << std::endl;
	}
);
//[&var]表示引用传递捕捉变量var
int num = 100;
auto function = ([&num]{
		num = 1000;
		std::cout << "num: " << num << std::endl;
	}
);
//[&]表示引用传递方式捕捉所有父作用域的变量（包括this）
int index = 1;
int num = 100;
auto function = ([&]{
		num = 1000;
		index = 2;
		std::cout << "index: "<< index << ", " 
            << "num: "<< num << std::endl;
	}
);
//[this]表示值传递方式捕捉当前的this指针
class Lambda
{
public:
    void sayHello() {
        std::cout << "Hello" << std::endl;
    };

    void lambda() {
        auto function = [this]{ 
            this->sayHello(); 
        };

        function();
    }
};
 
int main()
{
    Lambda demo;
    demo.lambda();
}
//[=, &] 拷贝与引用混合
//[=,&a,&b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量。
int index = 1;
int num = 100;
auto function = ([=, &index, &num]{
		num = 1000;
		index = 2;
		std::cout << "index: "<< index << ", " 
            << "num: "<< num << std::endl;
	}
);
```

69、左值和右值（左址右值）

​		首先，左值和右值是表达式的属性。C++中的表达式，不是左值就是右值。左值可以位于赋值语句的左侧，而右值则不能；可以做一个简单的归纳：当一个对象被用作右值的时候，用的是对象的值；当对象被用作左值的时候，用的是对象的身份(在内存中的位置）。需要右值的地方可以用左值代替，但不能把右值当成左值使用。
​		左值引用就是我们平常使用的“引用”。引用是为对象起的别名，必须被初始化，与变量绑定到一起，且将一直绑定在一起。我们通过 & 来获得左值引用，可以把引用绑定到一个左值上，而不能绑定到要求转换的表达式、字面常量或是返回右值的表达式。举个例子：

```c++
int i = 42;
int &r = i;    //正确，左值引用
int &r1 = i * 42;   //错误， i*42是一个右值
const int &r2 = i * 42; //正确，可以将一个const的引用绑定到一个右值上
```

​		右值引用就是必须绑定到右值的引用，他有着与左值引用完全相反的绑定特性，我们通过 && 来获得右值引用。右值有一个重要的性质——只能绑定到一个将要销毁的对象上。举个例子：

```c++
int  &&rr = i;  //错误，i是一个变量，变量都是左值
int &&rr1 = i *42;  //正确，i*42是一个右值
```

​		左值拥有持久的状态，而右值要么是字面常量，要么是在表达式求职过程中创建的临时对象。右值引用的对象将要被销毁。不能将一个右值引用绑定到一个右值引用类型的变量上，因为变量都是左值。举个例子：

```c++
int &&rr1 = 42; //正确，42是右值
int &&rr2 = rr1; //错误，rr1是左值！
//但是我们可以显示的将一个左值转换成对应的右值引用类型。通过move函数来执行。
int &&rr3 = std::move(rr1);
```

70、 C++中的explicit关键字只能用于修饰只有一个参数的类构造函数， 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).

​		explicit关键字的作用就是防止类构造函数的隐式自动转换. explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了.但是，当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数。 

71、size_t

​		size_t是标准C库中定义的，它是一个基本的与机器相关的无符号整数的C/C + +类型， 它是sizeof操作符返回的结果类型，该类型的大小可选择。其大小足以保证存储内存中对象的大小（简单理解为 **unsigned int**就可以了，64位系统中为** long unsigned int **）。通常用sizeof(XX)操作，这个操作所得到的结果就是size_t类型。

​		使用size_t可能会提高代码的可移植性、有效性或者可读性，或许同时提高这三者。

​		详情**略**

72、尾置返回类型

​		用于函数返回类型的自动推导，一般用于**返回类型比较复杂**，或者需要**通过模板参数（亦或其它表达式）来推导返回类型**的情况，通常会结合 **decltype** 一起使用，本质上算是一种语法，在函数定义的**参数列表右侧添加       -> ReturnType** 来**代表函数返回类型**，将**通常放置函数返回类型的地方使用 auto 代替**。

```c++
//比如
auto FuncName(ArgsList) -> ReturnType { }
// 结合decltype，依据模板参数推导返回类型 
template<typename ArgType1, typename ArgType2>
auto Func1(ArgType1& a, ArgType2& b) -> decltype(a + b) 
{ 
    return (a + b);
}

// 在C++14中可省略箭头返回值部分，直接将函数返回类型设置为auto 
template<typename ArgType1, typename ArgType2>
auto Func2(ArgType1& a, ArgType2& b)
{ 
    return (a + b);
}

// 也可以直接将返回类型定义为 decltype(auto) 
template<typename ArgType1, typename ArgType2>
decltype(auto) Func3(ArgType1& a, ArgType2& b)
{
    return (a + b);
}
```

**特别注意：**对于上述 Func1、Func2 和 Func3 的**函数定义是等价的**，当它们都是相同函数名时相当于定义了多个相同的重载函数，但是这种等价的定义在**不使用时不会导致编译报错**，而在实际**调用**中，会因为对**重载函数的不明确调用**而导致编译报错。

```c++
/*将尾置返回类型放在参数列表后面，是因为C++函数的返回类型是前置定义，在前置定义中，此时还未定义参数列表，所以如果要通过参数来推导返回类型就必须将推导的表达式放在参数列表后面，C++14虽然可以省略类型推导表达式，但仍然不能在前置定义的返回类型中依据参数推导返回类型：*/
//编译报错，找不到 a 和 b 的定义 
template<typename ArgType1, typename ArgType2>
decltype(a + b) Func4(ArgType1& a, ArgType2& b)
{
    return (a + b);
}

// 需要注意的是上述代码不代表 decltype 不能用于函数前置声明，如：
vector<int> VEC;
template<typename ArgType1, typename ArgType2>
decltype(VEC) Func5(ArgType1 a, ArgType2 b)
{
    vector<int> arr{a, b};
    return arr;
}
```

而关于decltype：

 decltype是C++11新增的一个关键字，和auto的功能一样，用来在**编译时期**进行自动类型推导。引入decltype是因为auto并不适用于所有的自动类型推导场景，在某些特殊情况下auto用起来很不方便，甚至压根无法使用。

```c++
auto varName=value;
decltype(exp) varName=value;
```

​	auto根据=右边的初始值推导出变量的类型，decltype根据exp表达式推导出变量的类型，跟=右边的value没有关系
​	auto要求变量必须初始化，这是因为auto根据变量的初始值来推导变量类型的，如果不初始化，变量的类型也就无法推导
​	而decltype不要求，因此可以写成如下形式

```c++
decltype(exp) varName;
```

73、关于**扩展Args**    变参数模板、模板形参包的内容，后续C++新标准的时候再做归纳整理

74、正则表达式        **正则程序库（regex）**

「正则表达式」就是一套表示规则的式子，专门用来处理各种复杂的操作。

std::regex是C++用来表示「正则表达式」（regular expression）的库，于C++11加入，它是class std::basic_regex<>针对char类型的一个特化，还有一个针对wchar_t类型的特化为std::wregex。

std::regex默认使用是ECMAScript文法，这种文法比较好用，且威力强大，常用符号的意义如下：

| 符号 | 意义                        |
| ---- | --------------------------- |
| ^    | 匹配行的开头                |
| $    | 匹配行的结尾                |
| .    | 匹配任意单个字符            |
| […]  | 匹配[]中的任意一个字符      |
| (…)  | 设定分组                    |
| \    | 转义字符                    |
| \d   | 匹配数字[0-9]               |
| \D   | \d 取反                     |
| \w   | 匹配字母[a-z]，数字，下划线 |
| \W   | \w 取反                     |
| \s   | 匹配空格                    |
| \S   | \s 取反                     |
| +    | 前面的元素重复1次或多次     |
| *    | 前面的元素重复任意次        |
| ?    | 前面的元素重复0次或1次      |
| \|   | 逻辑或                      |

以下，正则表达式常用内容仅列匹配(Match)其余在STL.xmind中有归纳。

```c++
/*字符串处理常用的一个操作是「匹配」，即字符串和规则恰好对应，而用于匹配的函数为std::regex_match()，它是个函数模板*/
//这个小例子使用regex_match()来匹配xml格式（或是html格式）的字符串，匹配成功则会返回true
std::regex reg("<.*>.*</.*>");
bool ret = std::regex_match("<html>value</html>", reg);
assert(ret);

ret = std::regex_match("<xml>value<xml>", reg);
assert(!ret);

std::regex reg1("<(.*)>.*</\\1>");
ret = std::regex_match("<xml>value</xml>", reg1);
assert(ret);

ret = std::regex_match("<header>value</header>", std::regex("<(.*)>value</\\1>"));
assert(ret);

// 使用basic文法
std::regex reg2("<\\(.*\\)>.*</\\1>", std::regex_constants::basic);
ret = std::regex_match("<title>value</title>", reg2);
assert(ret);
//对于语句中出现\\，是因为\需要转义，C++11以后支持原生字符，所以也可以这样使用：
std::regex reg1(R"(<(.*)>.*</\1>)");
auto ret = std::regex_match("<xml>value</xml>", reg1);
assert(ret);
```

若是想得到匹配的结果，可以使用regex_match()的另一个重载形式：

```c++
std::cmatch m;
auto ret = std::regex_match("<xml>value</xml>", m, std::regex("<(.*)>(.*)</(\\1)>"));
if (ret)
{
	std::cout << m.str() << std::endl;
	std::cout << m.length() << std::endl;
	std::cout << m.position() << std::endl;
}

std::cout << "----------------" << std::endl;

// 遍历匹配内容
for (auto i = 0; i < m.size(); ++i)
{
	// 两种方式都可以
	std::cout << m[i].str() << " " << m.str(i) << std::endl;
}

std::cout << "----------------" << std::endl;

// 使用迭代器遍历
for (auto pos = m.begin(); pos != m.end(); ++pos)
{
	std::cout << *pos << std::endl;
}

//输出结果为：
<xml>value</xml>
16
0
----------------
<xml>value</xml> <xml>value</xml>
xml xml
value value
xml xml
----------------
<xml>value</xml>
xml
value
xml
```

75、C++11互斥量mutex

​	这一部分仅作引入，详情静待C++多线程以及Linux环境下编译。

​		mutex又称互斥量，C++ 11中与 mutex相关的类（包括锁类型）和函数都声明在#include<mutex>头文件中，所以如果你需要使用 std::mutex，就必须包含#include<mutex>头文件。

C++11提供如下4种语义的互斥量（mutex） ：

1. std::mutex，独占的互斥量，不能递归使用。
2. std::time_mutex，带超时的独占互斥量，不能递归使用。
3. std::recursive_mutex，递归互斥量，不带超时功能。
4. std::recursive_timed_mutex，带超时的递归互斥量。

std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性，即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。

​	std::mutex 的成员函数：

1. 构造函数，**std::mutex不允许拷贝构造，也不允许 move 拷贝**，最初产生的 mutex 对象是处于 unlocked 状态的。
2. lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没 有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当 前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁 住，则会产生死锁(deadlock)。
3. unlock()， 解锁，释放对互斥量的所有权。
4. try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该 函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直 到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。

76、当前文档部分结束。